package org.jredfoot.utgrid.node.charts;

import java.io.File;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.NumberTickUnit;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.data.Range;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jredfoot.utgrid.common.node.GridNodeExecutionMetrics;
import org.jredfoot.utgrid.node.statistics.SigarCpuInfo;
import org.jredfoot.utgrid.node.statistics.SystemAnalytics;

/**
 *
 * @author marcelo
 */
public class SystemInformationChart extends javax.swing.JFrame {

    XYSeries cpuUserTime = new XYSeries("Tempo de Usuário");
    XYSeries cpuSysTime  = new XYSeries("Tempo de Sistema");
    XYSeries cpuIdleTime = new XYSeries("Tempo Ocioso");
    XYSeries cpuLoadAvg = new XYSeries("Média Sigar");
    XYSeries cpuLoadAvgJmx = new XYSeries("Média JDK");
    XYSeriesCollection cpuSeries = null;
    long contadorCPU = 100;
    JFreeChart chartCPU;
    ChartPanel chartPanelCPU;

    XYSeries memoryHeapUsada = new XYSeries("Memória Heap Usada");
    XYSeries memoryHeapComitada = new XYSeries("Memória Heap Comitada");
    XYSeries memoryNaoHeapUsada = new XYSeries("Memória Usada");
    XYSeries memoryNaoHeapComitada = new XYSeries("Memória Comitada");
    XYSeriesCollection memorySeries = null;
    long contadorMemory = 100;
    JFreeChart chartMemory;
    ChartPanel chartPanelMemory;

    XYSeries threadCount = new XYSeries("Threads");
    XYSeries peakThreadCount = new XYSeries("Peak Threads");
    XYSeries totalStartedThreadCount = new XYSeries("Total de Threads");
    XYSeries daemonThreadCount = new XYSeries("Threads em Background");
    XYSeriesCollection threadSeries = null;
    long contadorThread = 100;
    JFreeChart chartThread;
    ChartPanel chartPanelThread;

    XYSeries memoryLivre = new XYSeries("Memória Livre");
    XYSeries memoryUsada = new XYSeries("Memória Usada");
    XYSeries memorySwapLivre = new XYSeries("Swap Livre");
    XYSeries memorySwapUsada = new XYSeries("Swap Usada");
    XYSeriesCollection memoryGeralSeries = null;
    long contadorGeralMemory = 100;
    JFreeChart chartGeralMemory;
    ChartPanel chartPanelGeralMemory;

    private Date dataAtual = new Date();

    private GridNodeExecutionMetrics metricasLocais;

    private SystemAnalytics carregador = new SystemAnalytics();

    private Timer timer;

    private boolean isJdkValue = !carregador.isPreferSigar();

    private boolean isSigarPresent = carregador.isSigarPresent();


    /** Creates new form PainelEletronico */
    public SystemInformationChart() {
        initComponents();
        initGraficoCPU();
        initGraficoMemoria();
        initGraficoThread();
        if(isSigarPresent){
            initGraficoMemoriaGeral();
        }

        initTimer();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {

        jTabbedPane1 = new javax.swing.JTabbedPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 888, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 497, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        initLibraryPath();
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SystemInformationChart().setVisible(true);
                int cpus = new SigarCpuInfo().getNumeroCpu();
                for(int i = 0; i < cpus; i++){
                    new SigarCpuInfoChart(i).setVisible(true);
                }
            }
        });
    }

    public static void initLibraryPath(){
        System.setProperty("java.library.path", System.getProperty("java.library.path") + ";" + new File("").getAbsolutePath() + File.separator + "lib" );
    }

    public void initTimer(){
        timer = new Timer();
        timer.schedule(new AtualizaGrafico(), new Date(), 1000);
    }

    public void initGraficoCPU(){
        cpuSeries = new XYSeriesCollection();
        if(isSigarPresent){
            cpuSeries.addSeries(cpuUserTime);
            cpuSeries.addSeries(cpuSysTime);
            cpuSeries.addSeries(cpuIdleTime);
            cpuSeries.addSeries(cpuLoadAvg);
        }
        if(isJdkValue){
            cpuSeries.addSeries(cpuLoadAvgJmx);
        }

        chartCPU = ChartFactory.createXYLineChart(
                "Gráfico de Uso do(s) Processador(s)" ,
                "Decurso de Tempo (seg.)",
                "Percentuais",
                cpuSeries ,
                PlotOrientation.VERTICAL,
                true,
                true,
                false
        );


        XYPlot xyp = chartCPU.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getRangeAxis();
        axis.setAutoRange(false);
        axis.setRange(0.0, 100.0);
        axis.setTickUnit(new NumberTickUnit(10));
        axis = (NumberAxis)xyp.getDomainAxis();
        axis.setRange( new Range( 0.0, 100.0), true, true );
        axis.setTickUnit(new NumberTickUnit(10));
        chartPanelCPU = new ChartPanel(chartCPU);
        chartPanelCPU.setPreferredSize(new java.awt.Dimension(250,300));
        jTabbedPane1.add("Processador", chartPanelCPU);

    }

    public void initGraficoMemoria(){
        memorySeries = new XYSeriesCollection();
        memorySeries.addSeries(memoryHeapUsada);
        memorySeries.addSeries(memoryHeapComitada);
        memorySeries.addSeries(memoryNaoHeapUsada);
        memorySeries.addSeries(memoryNaoHeapComitada);

        chartMemory = ChartFactory.createXYLineChart(
                "Gráfico de Uso de Memórias" ,
                "Decurso de Tempo (seg.)",
                "Quantidade (Bytes)",
                memorySeries ,
                PlotOrientation.VERTICAL,
                true,
                true,
                false
        );


        XYPlot xyp = chartCPU.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getRangeAxis();
        //axis.setAutoRange(false);
        //axis.setRange(0.0, 100.0);
        //axis.setTickUnit(new NumberTickUnit(10));
        //axis = (NumberAxis)xyp.getDomainAxis();
        //axis.setRange( new Range( 0.0, 100.0), true, true );
        //axis.setTickUnit(new NumberTickUnit(10));
        chartPanelMemory = new ChartPanel(chartMemory);
        chartPanelMemory.setPreferredSize(new java.awt.Dimension(250,300));
        jTabbedPane1.add("Memória JVM", chartPanelMemory);

    }

    public void initGraficoThread(){
        threadSeries = new XYSeriesCollection();
        threadSeries.addSeries(threadCount);
        threadSeries.addSeries(peakThreadCount);
        threadSeries.addSeries(totalStartedThreadCount);
        threadSeries.addSeries(daemonThreadCount);

        chartThread = ChartFactory.createXYLineChart(
                "Threads em Execução" ,
                "Decurso de Tempo (seg.)",
                "Quantidade",
                threadSeries ,
                PlotOrientation.VERTICAL,
                true,
                true,
                false
        );


        XYPlot xyp = chartThread.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getRangeAxis();
        //axis.setAutoRange(false);
        //axis.setRange(0.0, 100.0);
        //axis.setTickUnit(new NumberTickUnit(10));
        //axis = (NumberAxis)xyp.getDomainAxis();
        //axis.setRange( new Range( 0.0, 100.0), true, true );
        //axis.setTickUnit(new NumberTickUnit(10));
        chartPanelThread = new ChartPanel(chartThread);
        chartPanelThread.setPreferredSize(new java.awt.Dimension(250,300));
        jTabbedPane1.add("Threads JVM", chartPanelThread);

    }

    public void initGraficoMemoriaGeral(){
        memoryGeralSeries = new XYSeriesCollection();
        memoryGeralSeries.addSeries(memoryLivre);
        memoryGeralSeries.addSeries(memoryUsada);
        memoryGeralSeries.addSeries(memorySwapLivre);
        memoryGeralSeries.addSeries(memorySwapUsada);

        chartGeralMemory = ChartFactory.createXYLineChart(
                "Gráfico de Uso de Memórias" ,
                "Decurso de Tempo (seg.)",
                "Quantidade (Mega)",
                memoryGeralSeries ,
                PlotOrientation.VERTICAL,
                true,
                true,
                false
        );


        XYPlot xyp = chartGeralMemory.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getRangeAxis();
        //axis.setAutoRange(false);
        //axis.setRange(0.0, 100.0);
        //axis.setTickUnit(new NumberTickUnit(10));
        //axis = (NumberAxis)xyp.getDomainAxis();
        //axis.setRange( new Range( 0.0, 100.0), true, true );
        //axis.setTickUnit(new NumberTickUnit(10));
        chartPanelGeralMemory = new ChartPanel(chartGeralMemory);
        chartPanelGeralMemory.setPreferredSize(new java.awt.Dimension(250,300));
        jTabbedPane1.add("Memória Geral", chartPanelGeralMemory);

    }

    public void updateMetricas(){
        this.metricasLocais = carregador.getMetrics();
    }

    public void updateGraficoCPU(){

        Date data = new Date();

        long tempoAtual = (data.getTime() - dataAtual.getTime()) / 1000;

        if(cpuUserTime.getItemCount() == 100){
           contadorCPU = tempoAtual;
           if(isSigarPresent){
               cpuUserTime.remove(0);
               cpuSysTime.remove(0);
               cpuIdleTime.remove(0);
               cpuLoadAvg.remove(0);
           }
           if(isJdkValue){
               cpuLoadAvgJmx.remove(0);
           }
        }

        if(isSigarPresent){
            cpuUserTime.add(tempoAtual, this.metricasLocais.getUserOverloadProcessor() * 100);
            cpuSysTime.add( tempoAtual, this.metricasLocais.getSystemOverloadProcessor() * 100);
            cpuIdleTime.add(tempoAtual, this.metricasLocais.getIdleTimeProcessor() * 100);
            cpuLoadAvg.add(tempoAtual, this.metricasLocais.getCombinedOverloadProcessor() * 100);
        }
        if(isJdkValue){
            cpuLoadAvgJmx.add(tempoAtual, this.metricasLocais.getCurrentOverloadProcessor() * 1000);
        }

        XYPlot xyp = chartCPU.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getDomainAxis();
        axis.setRange( new Range( contadorCPU - 100, contadorCPU), true, true );
        chartPanelCPU.revalidate();
        chartPanelCPU.repaint();
    }

    public void updateGraficoMemory(){

        Date data = new Date();

        long tempoAtual = (data.getTime() - dataAtual.getTime()) / 1000;

        if(memoryHeapUsada.getItemCount() == 100){
           contadorMemory = tempoAtual;
           memoryHeapComitada.remove(0);
           memoryHeapUsada.remove(0);
           memoryNaoHeapComitada.remove(0);
           memoryNaoHeapUsada.remove(0);
        }

        memoryHeapComitada.add(tempoAtual, this.metricasLocais.getMemHeapCommited() / 1048576);
        memoryHeapUsada.add( tempoAtual, this.metricasLocais.getMemHeapUsed() / 1048576);
        memoryNaoHeapComitada.add(tempoAtual, this.metricasLocais.getMemNoHeapCommited() / 1048576);
        memoryNaoHeapUsada.add(tempoAtual, this.metricasLocais.getMemNoHeapUsed() / 1048576);

        XYPlot xyp = chartMemory.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getDomainAxis();
        axis.setRange( new Range( contadorMemory - 100, contadorMemory), true, true );
        chartPanelMemory.revalidate();
        chartPanelMemory.repaint();
    }

     public void updateGraficoThreads(){

        Date data = new Date();

        long tempoAtual = (data.getTime() - dataAtual.getTime()) / 1000;

        if(threadCount.getItemCount() == 100){
           contadorThread = tempoAtual;
           threadCount.remove(0);
           peakThreadCount.remove(0);
           totalStartedThreadCount.remove(0);
           daemonThreadCount.remove(0);
        }

        threadCount.add(tempoAtual, this.metricasLocais.getThreadCount());
        peakThreadCount.add( tempoAtual, this.metricasLocais.getPeakThreadCount());
        totalStartedThreadCount.add(tempoAtual, this.metricasLocais.getTotalStartedThreadCount());
        daemonThreadCount.add(tempoAtual, this.metricasLocais.getDaemonThreadCount());

        XYPlot xyp = chartThread.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getDomainAxis();
        axis.setRange( new Range( contadorThread - 100, contadorThread), true, true );
        chartPanelThread.revalidate();
        chartPanelThread.repaint();
    }

     public void updateGraficoGeralMemory(){

        Date data = new Date();

        long tempoAtual = (data.getTime() - dataAtual.getTime()) / 1000;

        if(memoryLivre.getItemCount() == 100){
           contadorGeralMemory = tempoAtual;
           memoryLivre.remove(0);
           memoryUsada.remove(0);
           memorySwapLivre.remove(0);
           memorySwapUsada.remove(0);
        }

        memoryLivre.add(tempoAtual, this.metricasLocais.getMemFree() / 1048576);
        memoryUsada.add( tempoAtual, this.metricasLocais.getMemUsed() / 1048576);
        memorySwapLivre.add(tempoAtual, this.metricasLocais.getMemSwapFree() / 1048576);
        memorySwapUsada.add(tempoAtual, this.metricasLocais.getMemSwapUsed() / 1048576);

        XYPlot xyp = chartGeralMemory.getXYPlot();
        NumberAxis axis = (NumberAxis)xyp.getDomainAxis();
        axis.setRange( new Range( contadorGeralMemory - 100, contadorGeralMemory), true, true );
        chartPanelGeralMemory.revalidate();
        chartPanelGeralMemory.repaint();
    }

    class AtualizaGrafico extends TimerTask {
        @Override
        public void run() {
            updateMetricas();
            updateGraficoCPU();
            updateGraficoMemory();
            updateGraficoThreads();
            if(isSigarPresent){
                updateGraficoGeralMemory();
            }
        }

    }

    private javax.swing.JTabbedPane jTabbedPane1;

}
